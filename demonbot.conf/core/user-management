#!/bin/bash
# Read the list of known users from the known users savefile.
load_users () {
    log -c 'Parsing users file.'
    users=()
    if [[ ! -f "$users_file" ]]; then
        log -c 'No users known.'
        return 0
    fi
    local h data
    while read -r h data; do
        [[ -z $data ]] && continue
        users["$h"]=$data
    done < "$users_file"
    log 'Read list of known users from disk.'
}

# Write the list of known users from to known users savefile.
save_users () {
    log -c 'Writing users file.'
    local h
    for h in "${!users[@]}"; do
        echo $h ${users["$h"]}
    done > "$users_file"
    log 'Wrote list of known users to disk.'
}

# Create or update user password and group information.
#
# Parameters:
#   username password [group ...]
update_user () {
    local name=${1,,}
    local home="$users_dir/$name"
    if [[ ! -d "$home" ]]; then
        log -c "Creating user directory: $user_dir"
        mkdir "$home"
    fi
    log -c "Setting password."
    sha1sum <<< "$2" | cut -d' ' -f1 > "$home/login-key"
    shift 2
    if [[ $1 ]]; then
        log -c "Setting groups."
        printf '%s\n' "$@" > "$home/groups"
    fi
    return 0
}

# Add a new hostmask to a user's trusted hostmask list.
#
# Parameters:
#   username mask [mask ...]
add_user_mask () {
    local name=${1,,}
    local home="$users_dir/$name"
    if [[ ! -d "$home" ]]; then
        log -c "No such user: $name"
        return 1
    fi
    shift
    printf '%s\n' "$@" >> "$home/masks"
    sort -u "$home/masks" > "$home/masks.new"
    mv "$home/masks.new" "$home/masks"
    return 0
}

# Determine whether a user is someone the bot knows personally by their mask.
# $sender and $sender_mask are expected to have been set by a PRIVMSG handler.
#
# Exit Codes:
#   0   User identified.
#   1   User unknown.
# Modifies Globals:
#   $groups     Which groups the user is in.
identify_user () {
    groups='global'
    [[ -z $sender || -z $sender_mask ]] && return 1
    if [[ ${users["$sender_mask"]} ]]; then
        groups=${users["$sender_mask"]}
        return 0
    fi
    local n
    for n in "$@" "$sender"; do
        [[ -z $n ]] && continue
        if grep -qFf "$users_dir/$n/masks" <<< "$sender_mask" 2>/dev/null
        then
            users["$sender_mask"]=$n
            [[ -f "$users_dir/$n/groups" ]] &&
                users["$sender_mask:groups"]=$(<"$users_dir/$n/groups")
            return 0
        fi
    done
    return 1
}

# Determine whether a user is in the specified group(s) by arguments.
# If no groups are specified, the 'global' group will be assumed.
#
# Parameters:
#   [group ...]
# Exit Codes:
#   0   User is in one or more of specified groups.
#   1   User is not in any of the specified groups.
check_clearance () {
    groups='global'
    [[ -z $sender || -z $sender_mask ]] && return 1
    local group
    identify_user && groups="users ${users["$sender_mask:groups"]}"
    [[ -z $1 ]] && set -- 'global'
    for group in $groups; do
        in_list "$group" 'root' "$@" &&
            return 0
    done
    return 1
}

