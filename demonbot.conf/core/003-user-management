#!/bin/bash
# Read the list of known users from the known users savefile.
#
# Return Codes:
#   0   Users read successfully
#   1   No known users
load_users () {
    log -c 'Parsing users file.'
    users=()
    if [[ ! -f "$users_file" ]]; then
        log 'No users known.'
        return 1
    fi
    local h data
    while read -r h data; do
        [[ $data ]] && users["$h"]=$data
    done < "$users_file"
    log -c 'Read list of known users from disk.'
}

# Write the list of known users from to known users savefile.
#
# Return Codes:
#   0   Savefile written successfully
#   1   Error while writing savefile
save_users () {
    log -c 'Writing users file.'
    local h
    for h in "${!users[@]}"; do
        echo $h ${users["$h"]}
    done > "$users_file" || return 1
    log -c 'Wrote list of known users to disk.'
}

# Return whether or not a user exists.
#
# Parameters:
#   name
# Return Codes:
#   0   User exists
#   1   User doesn't exist
# Modifies Globals:
#   $name   Name of the user
#   $home   Home directory of the user
is_user () {
    name=${1,,}
    home="$users_dir/$name"
    [[ -f "$home/login-key" ]]
}

# Create or update user password and group information.
#
# Parameters:
#   username password [group ...]
update_user () {
    local name home
    if ! is_user "$1"; then
        log -c "Creating user directory: $home"
        mkdir -p "$home"
    fi
    log -c "Setting password."
    sha1sum <<< "$2" | cut -d' ' -f1 > "$home/login-key"
    shift 2
    if [[ $1 ]]; then
        log -c "Setting groups."
        printf '%s\n' "$@" > "$home/groups"
    fi
    return 0
}

# Add a new hostmask to a user's trusted hostmask list.
#
# Parameters:
#   username mask [mask ...]
add_user_mask () {
    local name home
    if ! is_user "$1"; then
        log -c "No such user: $name"
        return 1
    fi
    shift
    printf '%s\n' "$@" >> "$home/masks"
    sort -u "$home/masks" > "$home/masks.new"
    mv "$home/masks.new" "$home/masks"
    return 0
}

# Determine whether a user is someone the bot knows personally by their mask.
# $sender and $sender_mask are expected to have been set by a PRIVMSG handler.
#
# Parameters:
#   [username ...]
# Return Codes:
#   0   User identified
#   1   User unknown
# Modifies Globals:
#   $name       Identified username
#   $home       User's home directory
#   $groups     Which groups the user is in.
identify_user () {
    groups='global'
    [[ -z $sender || -z $sender_mask ]] && return 1
    if [[ ${users["$sender_mask"]} ]]; then
        name=${users["$sender_mask"]}
        home="$users_dir/$name"
        groups=${users["$sender_mask:groups"]}
        return 0
    fi
    for name in "$@" "$sender"; do
        [[ -z $name ]] && continue
        name=${name,,}
        home="$users_dir/$name"
        log -c "$home/masks"
        if grep -qF "$sender_mask" "$home/masks" 2>/dev/null
        then
            users["$sender_mask"]=$name
            [[ -f "$home/groups" ]] &&
                users["$sender_mask:groups"]=$(<"$home/groups")
            groups=${users["$sender_mask:groups"]}
            return 0
        fi
    done
    name='unknown'
    home="$users_dir/$name"
    return 1
}

# Determine whether a user is in the specified group(s) by arguments.
# If no groups are specified, the 'global' group will be assumed.
#
# Parameters:
#   [group ...]
# Exit Codes:
#   0   User is in one or more of specified groups.
#   1   User is not in any of the specified groups.
check_clearance () {
    groups='global'
    [[ -z $sender || -z $sender_mask ]] && return 1
    local group
    identify_user && groups="users ${users["$sender_mask:groups"]}"
    [[ -z $1 ]] && set -- 'global'
    for group in $groups; do
        in_list "$group" 'root' "$@" &&
            return 0
    done
    return 1
}




################
### Commands ###
################
default_groups='admin'

c_useradd () {
    local name home
    if [[ $origin == $sender ]]; then
        if is_user "$1"; then
            log 'Someone else is already using that name.'
            return 1
        elif check_clearance admin; then
            update_user "$@"
        else
            update_user "$1" "$2"
        fi
        if [[ $? == 0 ]]; then
            log "User added successfully."
        else
            log "There was a problem adding the user to the database."
        fi
    else
        log "Why are you trying to set this in the channel?! Send me a query! And don't use the same password!"
    fi
}
add_command useradd c_useradd global

c_userdel () {
    local name=${1,,} home
    if ! check_clearance admin && [[ $name != ${sender,,} ]]; then
        log "You're not powerful enough. You can only delete yourself."
        return 1
    elif ! is_user "$name"; then
        log "I do not have a user named $name."
        return 1
    fi
    rm -rf "$home/$name"
    log "User deleted."
}
add_command useradd c_useradd

c_groupadd () {
    local name home
    if ! is_user "$1"; then
        log "I do not have a user named $name."
        return 1
    fi
    shift
    printf '%s\n' "$@" >> "$home/groups"
    sort -u "$home/groups" > "$home/groups.new"
    mv "$home/groups.new" "$home/groups"
    log "User added to groups."
}
add_command groupadd c_groupadd

c_groupdel () {
    local name home
    if ! is_user "$1"; then
        log "I do not have a user named $name."
        return 1
    fi
    shift
    grep -vFf <(printf '%s\n' "$@") "$home/groups" > "$home/groups.new"
    mv "$home/groups.new" "$home/groups"
    log "User removed from groups."
}
add_command groupdel c_groupdel

c_master_override () {
    whisper
    if [[ $1 != $master_key ]]; then
        log 'Incorrect master key.'
        return 1
    fi
    users["${sender[1]}@${sender[2]}"]="${sender,,} root"
    log 'You now have master access to my core. ;)'
}
add_command master_override c_master_override global

c_identify () {
    local name home
    if [[ $origin == $sender ]]; then
        if ! is_user "$1"; then
            log "Incorrect username or password."
            return 1
        fi
        local key=$(sha1sum <<< "$2" | cut -d' ' -f1)
        local correct_key=$(<"$home/login-key")
        if [[ $key != $correct_key ]]; then
            log "Incorrect username or password."
            return 1
        fi
        add_user_mask "$name" "$sender_mask"
        if identify_user "$name"; then
            log "Hello, $name. You have been successfully identified."
            return 0
        else
            log "You could not be identified."
            return 1
        fi
    else
        log "You're not supposed to tell me this in the channel! Send me a query next time!"
        if is_user "$1"; then
            local key=$(sha1sum <<< "$2" | cut -d' ' -f1)
            local correct_key=$(<"$home/login-key")
            local new_pass=$(cat /dev/urandom | tr -dc '[:alnum:]' | head -c50)
            if [[ $key == $correct_key ]]; then
                update_user "$1" "$new_pass"
                whisper
                log "I changed your password to: $new_pass"
                log "After you identify, change this with: passwd $new_pass NEW_PASSWORD"
            else
                log "The password was incorrect. You should change it after you identify. Preferably right now."
            fi
        fi
    fi
}
add_command identify c_identify global

c_passwd () {
    local name home
    if [[ $origin == $sender ]]; then
        if ! identify_user; then
            log "I can't figure out which user you are. Identify yourself."
            return 1
        fi
        local key=$(sha1sum <<< "$1" | cut -d' ' -f1)
        local correct_key=$(<"$home/login-key")
        if [[ $key != $correct_key ]]; then
            log "Incorrect old password."
            return 1
        fi
        update_user "$name" "$2"
        log "Your password has been updated."
    else
        log "Why are you trying to set this in the channel?! Send me a query! And don't use the same password!"
    fi
}
add_command passwd c_passwd global

load_users
_unload_core-save_users () { save_users; }
