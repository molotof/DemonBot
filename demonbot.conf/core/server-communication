#!/bin/bash
# Connect to an IRC server and punt IRC messages.to a parser loop.
#
# Parameters:
#   host [port [connector]]
connect () {
    while $next_host; do
        exec 9<&-
        exec 9<>"$demonbot_io"
        if [[ -z $host ]]; then
            log -c 'Missing host.'
            return 1
        fi
        port=${port:-6667}
        connector=${connector:-tcp}
        con_bin=${connectors["$connector"]}
        if ! in_list "$(cmd_type "$con_bin")" 'function' 'file'; then
            log -c "$connector '$con_bin' isn't executable."
            return 1
        fi
        log -c "Connecting to ${connector^^} host $host:$port."
        unset logged_in user_disconnect
        coproc connection {
            echo '!connect' >&9
            $con_bin "$host" "$port" >&9 2> >(read_do log -d)
            echo '!disconnect' >&9
        }
        parser_loop
        exec 9<&-
        [[ $user_disconnect || $reconnect_auto < 1 ]] &&
            break
        if [[ $hosts ]]; then
            log -c "Waiting $reconnect_secs seconds to reconnect."
            sleep $reconnect_secs
        fi
    done
}

# Parses lines from IRC server and punts it to a handler.
parser_loop () {
    local handler prefix event args line
    while read -r line; do
        if [[ ${line:0:1} == ':' ]]; then
            read -r prefix event line <<< "${line:1}"
        else
            prefix=$host
            read -r event line <<< "$line"
        fi
        [[ -z $event ]] && continue
        event=${event,,}
        IFS=':' read -r args line <<< "$line"
        if [[ ${handlers["$event"]} ]]; then
            log -d "Handling $event with: ${handlers["$event"]}"
            for handler in ${handlers["$event"]}; do
                $handler "$event" "$prefix" $args "$line"
            done
        elif [[ ${handlers['unknown']} ]]; then
            log -d "Handling $event with: ${handlers['unknown']}"
            ${handlers['unknown']} "$event" "$prefix" $args "$line"
        fi
        [[ ${handlers['all']} ]] &&
            ${handlers['all']} "$event" "$prefix" $args "$line"
        case "$event" in
            '!disconnect')
                unset logged_in
                log -c 'Disconnected from server.'
                break
                ;;
            '!connect')
                login ||
                    log -c 'Could not log into server.'
                ;;
        esac
    done <&9
}

# Send command to IRC server.
#
# Parameters:
#   command data
send () {
    local IFS=' '
    if [[ ${connection[1]} ]]; then
        if [[ ${1:0:1} != ':' ]]; then
            echo "${1^^} ${*:2}" >&${connection[1]}
        else
            echo "$1 ${2^^} ${*:3}" >&${connection[1]}
        fi
    else
        log -c 'Not connected to server.'
        return 1
    fi
}

# Send login information to IRC server.
login () {
    if [[ $pass ]]; then
        send pass "$pass" || return 1
    fi
    send nick "$nick" || return 1
    send user "$user $mode * :$name" || return 1
}

# Send a private message.
#
# Parameters:
#   target message [message ...]
privmsg () {
    if [[ -z $2 ]]; then
        log -c 'No target or message set!'
        return 1
    fi
    local message line target=$1
    shift
    for message in "$@"; do
        log -c "Telling $target: $message"
        while read -r line; do
            send privmsg "$target" ":$line"
        done < <(fold -s -w $((497-${#target})) <<< "$message")
    done
}

# Send a CTCP message.
#
# Parameters:
#   type target message
ctcp () {
    if [[ $1 == '-r' ]]; then
        local reply='notice'
        shift
    fi
    if [[ -z $2 ]]; then
        log -c 'No type or message set!'
        return 1
    fi
    local message line name=${1^^} target=$2
    shift 2
    for message in "$@"; do
        log -c "CTCP ${name^^} ${reply:-query} to $target: $message"
        while read -r line; do
            send ${reply:-privmsg} "$target" $':\x01'"$name $line"$'\x01'
        done < <(fold -s -w $((497-${#target}-${#name})) <<< "$message")
    done
}

# Send an action message.
#
# Parameters:
#   target message
action () {
    ctcp action "$1" "$2"
}


# Loop-rotate to the next host in the hosts list.
#
# Parameters:
#   ['prev']
rotate_host () {
    local IFS=$oifs
    read host port connector trash <<< "$hosts"
    port=${port:-6667}
    connector=${connector:-tcp}
    log -c "Selected ${connector^^} host $host:$port."
    if [[ ${#hosts[@]} -gt 1 ]]; then
        if [[ $1 == 'prev' ]]; then
            hosts=("${hosts[-1]}" "${hosts[@]:0:((${#hosts[@]}-1))}")
        else
            hosts=("${hosts[@]:1}" $hosts)
        fi
    fi
}

# Switch to the next host in the hosts list.
pop_host () {
    if [[ -z $hosts ]]; then
        log -c 'There are no more hosts to switch to.'
        return 1
    fi
    local trash IFS=$oifs
    read host port connector trash <<< "$hosts"
    port=${port:-6667}
    connector=${connector:-tcp}
    log -c "Selected ${connector^^} host $host:$port."
    hosts=("${hosts[@]:1}")
}

# Loop-rotate to the next nick in the nicks list.
#
# Parameters:
#   ['prev']
rotate_nick () {
    nick=$nicks
    log -c "Trying nick: $nick"
    if [[ ${#nicks[@]} -gt 1 ]]; then
        if [[ $1 == 'prev' ]]; then
            nicks=("${nicks[-1]}" "${nicks[@]:0:((${#nicks[@]}-1))}")
        else
            nicks=("${nicks[@]:1}" $nicks)
        fi
    fi
}

# Switch to the next nick in the nicks list.
pop_nick () {
    if [[ -z $nicks ]]; then
        log -c 'There are no more nicks to switch to.'
        return 1
    fi
    nick=$nicks
    log -c "Trying nick: $nick"
    nicks=("${nicks[@]:1}")
}

# Join channels specified in join list.
join_auto () {
    event -c join "${join[@]}"
}


##################
### Connectors ###
##################
socat_tcp () {
    socat STDIO TCP:"$1":"$2",crlf
}
add_connector -p tcp socat_tcp

socat_ssl () {
    socat STDIO OPENSSL:"$1":"$2",verify=0,crlf
}
add_connector -p ssl socat_ssl

socat_socks () {
    socks_host=${socks_host:-localhost}
    socks_port=${socks_port:-9999}
    socat STDIO \
        SOCKS4A:"$socks_host":"$1":"$2",socksport="$socks_port",crlf
}
add_connector -p socks socat_socks


################
### Handlers ###
################
h_privmsg () {
    log -c "<$2 $3> $4"
    local is_command text=${4##$'\x03'*([[:digit:],])}
    local sender=($(split_hostmask "$2")) origin=($(split_hostmask "$3"))
    local sender_mask=${2#*'!'}
    [[ ${text:0:1} == $cmd_char ]] &&
        is_command=1 text=${text:1}
    [[ $origin == $nick ]] &&
        is_command=1 origin=(${sender[@]})
    if [[ $is_command ]]; then
        local IFS=$'\n\r'
        event -cp cmd $(split_strings "$text")
    fi
}
add_handler -p privmsg h_privmsg


################
### Commands ###
################
default_groups='admin'

c_privmsg () {
    local IFS=' ' target=$1
    shift
    privmsg "$target" "$*"
}
add_command -p privmsg c_privmsg

c_action () {
    local IFS=' ' target=$1
    shift
    action "$target" "$*"
}
add_command -p action c_action

c_whisper () {
    local IFS=$'\n' target=${1:-$sender}
    action "$origin" "whispers something to $target."
    origin=(${sender[@]})
    shift
    local IFS=$oifs
    event -c cmd "$@"
}
add_command -p whisper c_whisper

