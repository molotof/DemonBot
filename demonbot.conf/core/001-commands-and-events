#!/bin/bash

# Execute an assigned command by name.
#
# Parameters:
#   [-p] [-b] command [param ...]
# Flags:
#   -p  Check user clearance beore running
#   -b  Run command in background
run_cmd () {
    local opt OPTIND
    unset opt_p opt_b
    while getopts pb opt; do
        declare "opt_$opt"=1
    done
    shift $((OPTIND - 1))
    local cmd=${1,,}
    [[ $cmd =~ ^[[:alnum:]~_.-]+$ && ${commands["$cmd"]} ]] || return 1
    if [[ $opt_p ]] && ! check_clearance ${commands["$cmd:groups"]}; then
        log "You are not powerful enough to use this command."
        return 1
    fi
    shift
    IFS=$oifs
    if [[ -z $opt_b ]]; then
        ${commands["$cmd"]} "$@"
    else
        ${commands["$cmd"]} "$@" &
    fi
    return 0
}

# Indirectly execute a command or generate an IRC event.
#
# Parameters (IRC event):
#   [-b] [:prefix] event [params] [:trailing]
# Parameters (command):
#   -c [-b] [-p] [params]
# Flags:
#   -c  Execute command
#   -p  Check permissions and only execute
#   -b  Run command in background
event () {
    local opt OPTIND
    unset opt_c opt_p opt_b
    while getopts cpb opt; do
        declare "opt_$opt"="-$opt"
    done
    shift $((OPTIND - 1))
    if [[ $opt_c ]]; then
        local IFS=$oifs event=$1
        shift
        run_cmd $opt_p $opt_b "$event" "$@" ||
            run_cmd $opt_p $opt_b unknown "$event" "$@"
        run_cmd $opt_p $opt_b all "$@"
    elif [[ ${connection[1]} ]]; then
        if [[ ${1:0:1} == ':' ]]; then
            local prefix="$1 " event=${2^^} data=$3
        else
            local IFS=' '
            local event=${1^^} data=$*
        fi
        echo "${prefix}$event $data" >&9
    else
        log -c 'Not connected to server.'
        return 1
    fi
}

